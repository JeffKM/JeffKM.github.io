---
layout: post
title:  "Learning Shell 2"
date:   2019-07-18 13:45:00 +0900
categories: [Language]
---
* TOC
{:toc}

# 참고서

"**리눅스 커맨드라인 완벽 입문서**"를 읽고 정리하였습니다.

# 리다이렉션

커맨드라인에는 **입출력 방향 지정(I/O 리다이렉션)**이라는 멋진 기능이 있습니다. I/O은 **입력/출력**을 뜻하고, 명령은 리다이렉션을
통해 파일로부터 입력받을 수 있고, 또한 파일로 출력할 수 있습니다. 뿐만 아니라 강력한 명령어 **파이프라인**을 만들기 위해서 필요한 
명령어들을 연결할 수 있습니다.

### 표준 입출력과 표준 오류

""모든 것은 파일이다""라는 유닉스 정신을 상기해보면 ls와 같은 프로그램은 사실 **표준 출력(stdout)**이라고 불리는 특수한 파일에
이 명령어에 대한 결과를 보내고 **표준 오류**라는 또 다른 파일에 그 상태 메세지를 전송합니다. 기본적으로 표준 출력과 오류 모두 화면에 연결되어 있고
디스크 파일에 따로 저장되지 않습니다. 게다가 많은 프로그램들이 **표준입력**이라고 부르는 곳에서 입력 내용을 가져오고 그것은 기본적으로
키보드에 직접 연결되어 있다.

### 리눅스 표준 입출력 리다이렉션(인터넷 자료)

쉘에서 키보드로 명령을 입력받는 것을 **표준 입력**이라 하며, 키보드로 입력 받은 명령의 실행결과를 모니터로 출력하는 것을 **표준 출력**이라고 합니다.
쉘에서 명령의 결과를 모니터로 출력하지 않고 파일로 저장할 수 있는데 이때 리다이렉션을 사용합니다. 리다이렉션을 사용하여 출력과 입력의 방향을 지정해 줄 수 있습니다.

| 리다이렉션 기호 | 방향 | 의미 |
| > | 표준 출력 | 명령>파일 : 명령의 결과를 파일로 저장 |
| >> | 표준 출력(추가) | 명령>>파일 : 명령의 결과를 기존 파일 데이터에 추가 |
| < | 표준 입력 | 명령<파일 : 파일의 데이터를 명령에 입력 |

#### cat - 파일 연결하기

**cat 명령어**는 다음과 같이 하나 이상의 파일을 읽어 들여서 표준 출력으로 그 내용을 복사합니다.

> cat [file...]

### 파이프 라인

파이프 연산자인 \| 기호를 사용해서 명령어의 표준 출력을 또 다른 명령어의 표준 입력과 연결시킬 수 있습니다.

> command1 \| command2


#### sort - 텍스트 라인 정렬하기

파이프라인은 데이터의 복잡한 연산을 수행할 때 종종 사용됩니다. 하나의 파이프라인에 여러 명렁어를 입력하는 것이 가능합니다. 주로 이러한 
방식을 사용하는 명령어들을 **필터**라고 합니다. 필터 중 하나로 **sort 명령어**가 있습니다.

```shell

[me@linuxbox ~]$ ls /bin /usr/bin | sort | less

```

파이프라인에 sort를 포함함으로써 하나로 정렬된 데이터 목록으로 바꿀 수 있었습니다.

#### uniq - 중복 줄을 알리거나 생략하기

uniq 명령어는 종종 sort와 연결하여 사용합니다. **uniq 명령어**는 표준 입력이나 하나의 파일명 인자로부터 정렬된 데이터 
목록을 입력받아 중복된 내용을 제거해줍니다. 중복된 내용을 보고 싶다면 -d 옵션을 사용하면 됩니다.

```shell

[me@linuxbox ~]$ ls /bin /usr/bin | sort | uniq | less

```

#### wc - 각 파일의 개행 및 단어 개수, 파일 바이트 출력하기

**wc 명령어**는 파일에 들어있는 단어 및 라인의 개수와 파일 크기를 표시해줍니다. 
-l 옵션은 라인 수만 보고 싶을 때 사용할 수 있습니다.

#### grep - 패턴과 일치하는 라인 출력하기

**grep 명령어**는 파일의 텍스트 패턴을 찾을 때 사용하는 강력한 프로그램입니다.

> grep pattern [file...]

grep은 **정규 표현식**이라고 하는 고급 수준의 패턴이나 간단한 패턴으로 파일 내에서 패턴을 만났을 때, 그 패턴을 가지고 있는 라인을 출력합니다.
-I 옵션은 검색을 수행할 때 대소문자를 구분하지 않도록 하고, -v 옵션은 패턴과 일치하지 않는 라인만 출력하도록 합니다.

#### head - 파일의 첫 부분 출력하기

**head 명령어**로 파일의 첫 10줄만 출력할 수 있습니다. -n 옵션을 사용하면 길이를 조절할 수 있습니다.

#### tail - 파일의 마지막 부분 출력하기

**tail 명령어**로 파일의 마지막 10줄을 출력할 수 있습니다. -n 옵션을 사용하면 길이를 조절할 수 있습니다. tail 명령어는 실시간으로 파일을
확인할 수 있는 옵션을 지원합니다. 로그파일이 기록되는 동안 최근 내용을 확인할 때 매우 편리합니다. -f 옵션을 사용하면, tail은 지속적으로 로그
파일을 감시하고 새 내용이 추가될 때 곧바로 그 내용을 표시합니다.

#### tee - 표준 입력을 읽고 표준 출력 및 파일에 쓰기

**tee 프로그램**은 표준 입력으로부터 데이터를 읽어서 표준 출력과 하나 이상의 다른 파일에 동시에 출력합니다. 이는 작업이
진행되고 있을 때, 중간 지점의 파이프라인에 있는 내용을 알고 싶을 때 유용합니다.

# 확장과 인용

#### echo

표준 출력상에 해당 텍스트 인자를 표시합니다.

### 경로명 확장

*기호 같이 와일드카드로 동작하는 방식을 **경로명 확장**이라고 합니다.

```shell

[me@linuxbox ~]$ echo D*
Dexktop Documents

```

### 틸드(~) 확장

```shell

[me@linuxbox ~]$ echo ~
/home/me

```
~ 기호 문자가 맨 앞에 있다면, 사용자의 홈 디렉토리 명을 나타냅니다.

### 산술 확장

> $((expression))

```shell

[me@linuxbox ~]$ echo $((2 + 2))
4

```

### 중괄호 확장

```shell

[me@linuxbox ~]$ echo Front-{A..C}-Back
Front-A-Back Front-B-Back Front-C-Back

```

중괄호에 의해 확장된 패턴은 프리앰블이라고 부르는 앞부분과 포스트스크립트라는 끝부분을 가집니다.

### 매개변수 확장

```shell

[me@linuxbox ~]$ echo $USER
me

```

```shell

[me@linuxbox ~]$ ls -l $(which cp)
-rwxr -xr -x 1 root root 71516 2012-12-05 08:58 /bin/cp

```

### 따옴표 활용

셀은 원하지 않는 확장을 선택적으로 감출 수 있도록 **따옴표 기호**를 활용하는 기능을 제공해줍니다.

**쌍따옴표 기호** 여부에 따른 차이 및 해결법
```shell

[me@linuxbox ~]$ ls -l two words.txt
ls: cannot access two: No such file or directory
ls: cannot access words.txt: No such file or directory

[me@linuxbox ~]$ ls -l "two words.txt"
-rw-rw-r-- 1 me me 18 2012-02-20 13:03 two words.txt
[me@linuxbox ~]$ mv "two words.txt" two_words.txt // 해결법

```

모든 확장을 숨겨야 한다면 **따옴표 기호**를 사용하면 됩니다.

```shell

[me@linuxbox ~]$ echo "text~/*.txt {a,b} $(echo foo) $((2 + 2)) $USER" 
text~/*.txt {a,b} foo 4 me
[me@linuxbox ~]$ echo 'text~/*.txt {a,b} $(echo foo) $((2 + 2)) $USER'
text~/*.txt {a,b} foo $(echo foo) $((2 + 2)) $USER

```

선택적으로 확장을 막거나 파일명에 있는 어떤 문자가 가지고 있는 특별한 의미를 없애고 싶을 때, 해당 문자 앞에 백슬래시를 추가하면 되는데,
이것을 **이스케이프 문자**라고 부릅니다.

# 고급 키보드 기법

### 커맨드라인 편집

#### 커서이동

커서 이동 명령어

| 키 | 실행 |
|:--:|:---:|
| CTRL-A | 줄 맨 앞으로 커서 이동 |
| CTRL-E | 줄 맨 끝으로 커서 이동 |
| CTRL-F | 다음 한 글자로 커서 이동. 오른쪽 화살표 키와 동일함 |
| CTRL-B | 이전 한 글자로 커서 이동. 왼쪽 화살표 키와 동일함 |
| ART-F | 다음 한 단어로 커서 이동 |
| ART-B | 이전 한 단어로 커서 이동 |
| CTRL-L | 화면을 지우고 커서를 왼쪽 최상단으로 이동. CLEAR 명령어와 동일함 |

#### 텍스트 수정

| 키 | 실행 |
|:--:|:---:|
| CTRL-D | 현재 커서 위치에 있는 글자 지우기 |
| CTRL-T | 현재 커서 위치에 있는 글자와 바로 앞 글자의 위치 바꾸기 |
| ART-T | 현재 커서 위치에 있는 단어와 바로 앞 단어의 위치 바꾸기 |
| ART-L | 현재 커서 위치에 있는 글자부터 그 단어 끝 부분까지 소문자로 바꾸기 |
| ART-U | 현재 커서 위치에 있는 글자부터 그 단어 끝 부분까지 대문자로 바꾸기 |

#### 텍스트 지우고 복사하기

| 키 | 실행 |
|:--:|:---:|
| CTRL-K | 현재 커서 위치로부터 그 줄 끝 부분까지 텍스트 지우기 |
| CTRL-U | 현재 커서 위치로부터 그 줄 처음 부분까지 텍스트 지우기 |
| ART-D | 현재 커서 위치에서부터 그 단어 끝 부분까지 텍스트 지우기 |
| ART-BACKSPACE | 현재 커서 위치에서부터 그 단어 앞부분까지 텍스트 삭제하기. 단, 커서가 단어 맨 앞에 위치하고 있다면 바로 앞 단어를 삭제함 |
| CTRL-Y | kill-ring에 있는 텍스트를 복사해서 현재 커서 위치에 삽입하기(잘라낸 데이터는 kill-ring이라고 하는 버퍼에 저장됩니다. |

### 자동 완성

명령어를 입력하는 동안 탭키를 누르면 자동 완성 기능이 작동합니다. 탭 키를 두번 입력하면 가능한 자동 완성 목록을 보여줍니다.

### 히스토리 활용

```shell

[me@linuxbox ~]$ history | grep /usr/bin

```

히스토리 확장

```shell

[me@linuxbox ~]$ !88

```
bash는 !88을 히스토리 목록에 있는 88번째 줄의 내용으로 확장시킬 것입니다.

히스토리 명령어

| 키 | 실행 |
|:--:|:---:|
| CTRL-P | 이전 히스토리 항목으로 이동. 위쪽 화살표키와 동일함. |
| CTRL-N | 다음 히스토리 항목으로 이동. 아래쪽 화살표키와 동일함. |
| ART-< | 히스토리 목록 처음으로 이동. |
| ART-> | 히스토리 목록 마지막으로 이동(현재 커맨드라인 기준). |
| CTRL-R | 역순 증분 검색. 현재 커맨드라인에서 히스토리 목록으로 증분 검색. |
| ART-P | 역순 검색. 증분 검색이 아님. 이 키 다음에, 검색 문자열을 입력한 후 검색이 실행되기 전에 엔터키를 누릅니다. |
| ART-N | 순방향 검색. 증분 검색 아님. |
| CTRL-O | 히스토리 목록에 있는 현재 항목을 실행하고 다음 항목으로 이동합니다. 히스토리 목록에 있는 순서대로 명령어를 재실행할 때 매우 편리함. |

증분 검색이란 명령어의 각 글가자 추가될 때마다 우리가 원하는 검색 결과를 골라서 보여주는 것입니다.

히스토리 확장 명령어

| 키 | 실행 |
|:--:|:---:|
| !! | 마지막 명령어를 반복하여 실행. 위쪽 화살표와 엔터키를 입력하는 것보다 아마 더 용이할 것입니다. |
| !number | 이 번호에 해당하는 항목을 실행. |
| !string | 이 문자열로 시작하는 가장 최근에 입력된 항목을 실행. |
| !?string | 이 문자열이 포함된 가장 최근에 입력된 항목을 실행. |

# 퍼미션

### 소유자, 그룹 멤버, 기타 사용자

```shell

[me@linuxbox ~]$ file /etc/shadow
/etc/shadow: regular file, no read permission
[me@linuxbox ~]$ less /etc/shadow
/etc/shadow: Permission denied

```
이 오류 메시지의 원인은 이 파일을 읽을 권한이 없는 일반 사용자이기 때문입니다.
유닉스 보안 모델에서 사용자는 파일과 디렉토리를 **소유**할 수 있습니다. 또한, 사용자들은 한 명 이상으로 구성된
**그룹**에 속할 수 있습니다. 소유자는 그룹이나 다른 모든 사용자에게 권한 일부를 줄 수 있습니다.

#### id - 사용자 ID 정보를 표시

자신의 사용자 ID 정보를 확인하기 위해서는 **id 명령어**를 사용합니다.

```shell

[me@linuxbox ~]$ id
uid=500(me) gid=500(me) groups=500(me)

```
사용자 계정이 생성되면, 사용자들은 **사용자 ID(uid라고 불리는 번호)**를 할당 받습니다. 그러고 나서 사용자를 위해서 사용자 이름을 할당합니다. 그 사용자는 **주 그룹 ID(gid)**를 할당 받고 추가로
다른 그룹에도 속할 수 있습니다. 위 정보들은 다수의 텍스트 파일에서 가져옵니다. 사용자 계정은 /etc/passwd 파일에 정의되어 있고, 그룹은 /etc/group 파일에 정의되어 있습니다.
사용자 계정과 그룹이 생성되면, 이 파일들은 사용자 비밀번호에 관한 정보를 가진 /etc/shadow에 덧붙여 수정됩니다. 각각의 사용자 계정은 /etc/passwd 파일에 그 사용자 이름, uid,
gid, 실제 사용자 이름, 홈 디렉토리와 로그인 쉘 정보가 저장됩니다.

### 읽기, 쓰기, 실행

파일과 디렉토리의 접근권은 읽기 권한, 쓰기 권한, 실행 권한이란 용어로 정의됩니다.

```shell

[me@linuxbox ~]$ > foo.txt
[me@linuxbox ~]$ ls -l foo.txt
-rw-rw-r-- 1 me  me  0 2012-03-06 14:52 foo.txt

```
처음 10개의 문자는 **파일 속성**을 나열한 것입니다. 첫 문자는 **파일종류**를 나타냅니다. 나머지 9개의 문자는 파일 모드라고 불립니다.
그것은 파일 소유자, 파일 소유 그룹, 기타 사용자에 대한 읽기, 쓰기, 실행 권한을 나타냅니다.

파일 종류

| 속성 | 파일 종류 |
|:---:|:-------:|
| - | 일반 파일 |
| d | 디렉토리 |
| l | 심볼릭 링크. 심볼릭 링크의 파일 속성은 항상 rwxrwxrwx이고 그것은 더미값입니다.. 실제 파일 속성은 심볼릭 링크가 가리키는 파일의 속성입니다.|
| c | 문자 특수 파일. 이 파일의 종류는 터미널이나 모뎁같이 바이트의 열로 데이터를 처리하는 디바이스를 나타냅니다. |
| b | 블록 특수 파일. 이 파일의 종류는 하드 드라이브나 CD-ROM 드라이브같이 블록 단위의 데이터를 처리하는 디바이스를 나타냅니다. |

퍼미션 속성

| 속성 | 파일 | 디렉토리 |
|:---:|:---:|:-----:|
| r | 파일 열기와 읽기를 허용합니다. | 실행 속성이 설정되어 있으면 디렉토리의 내용물을 나열할 수 있게끔 허용합니다. |
| w | 이 속성은 파일 쓰기와 잘라내기를 허용하지만, 이름 변경이나 파일 삭제는 허용하지 않습니다. 파일 삭제나 파일 이름 변경은 디렉토리 속성에 의해 결정됩니다. | 실행 속성이 설정되어 있으면 디렉토리 내의 파일들을 생성, 삭제, 이름 변경이 가능하도록 허용합니다. |
| x | 파일이 프로그램으로 처리되고 파일이 실행되도록 허용합니다. 스크립트 언어에서 작성된 프로그램 파일들은 읽기 가능으로 설정되어 있어야만 실행 가능합니다.| 디렉토리에 들어올 수 있도록 허용합니다. |

#### chmod - 파일 모드 변경

파일 또는 디렉토리의 모드를 변경하기 위해서 **chmod 명령어**를 사용합니다. 모드의 변경은 오직 파일 소유자나 슈퍼유저만이 가능합니다. 모드 변경을 표현하는 데는 2가지 방식이 있습니다.
첫번째로, 원하는 퍼미션 형태를 설정하기 위해 **8진수 표기법**을 사용합니다.

| 8진법 | 2진법 | 파일 모드 |
|:----:|:----:|:-------:|
| 0 | 000 | --- |
| 1 | 001 | --x |
| 2 | 010 | -w- |
| 3 | 011 | -wx |
| 4 | 100 | r-- |
| 5 | 101 | r-x |
| 6 | 110 | rw- |
| 7 | 111 | rwx |

```shell

[me@linuxbox ~]$ > foo.txt
[me@linuxbox ~]$ ls -l foo.txt
-rw-rw-r-- 1 me  me  0 2012-03-06 14:52 foo.txt
[me@linuxbox ~]$ chmod 600 foo.txt
[me@linuxbox ~]$ ls -l foo.txt
-rw------  1 me  me  0 2012-03-06 14:52 foo.txt

```

chmod는 또한 파일 모드를 지정하기 위해 문자 표기법을 지원합니다. 문자 표기법은 변경할 사용자, 수행할 명령, 설정할 퍼미션, 세 부분으로 나뉩니다.

| 기호 | 의미 |
|:---:|:---:|
| u | user의 약자로, 파일이나 디렉토리 소유자를 의미합니다. |
| g | 그룹 소유자 |
| o | others의 약자로, 기타 사용자를 의미합니다. |
| a | all의 약자로, u, g, o의 조합입니다. |

아무런 문자를 사용하지 않으면, 자연스럽게 all로 추정하고 그 명령은 퍼미션이 추가된 a +가 될 것입니다. a -는 퍼미션이 없어진다는 것을 나타내고, a =는 단지 지정된 퍼미션들만 적용되고 나머지
다른 것들은 제거될 것임을 나타냅니다.

#### unmask - 기본 권한 설정

**unmask 명령어**는 파일이 생성될 때 주어진 기본 퍼미션을 제어합니다. 파일 모드 속성에서 제거할 비트 **마스트**를 표현하기 위해 8진 표기법을 사용합니다.

```shell

[me@linuxbox ~]$ rm -f foo.txt
[me@linuxbox ~]$ umask
 0002
[me@linuxbox ~]$ > foo.txt
[me@linuxbox ~]$ ls -l foo.txt
 -rw-rw-rw-  1 me  me  0 2012-03-06 14:53 foo.txt

```

|:-----------:|:--------------:|
| 원래 파일 모드 | \-\-\- rw- rw- rw- |
| 마스크 | 000 000 000 010 |
| 결과 | \-\-\- rw- rw- r\-\- |

### 사용자 ID 변경

다양한 상황에서 다른 사용자의 ID가 필요할 수 있습니다. 관리 작업을 실행하기 위해 슈퍼 유저 특권을 얻기 원하거나 테스트 계정으로 이러한 작업을 수행하기 위해
다른 일반 사용자가 되는 것을 원합니다. 다른 사용자 ID를 사용하는 방법은 세 가지 방법이 있습니다.(첫 번째 방법은 로그아웃 후 다른 사용자로 로그인하기)

#### su - 다른 사용자 ID와 그룹 ID로 쉘 실행

**su 명령어**는 다른 사용자로 쉘을 시작하기 위해 사용합니다.

> su [-[l]] [user]

만약 -l 옵션을 사용하면, 반환된 쉘 세션은 이 명령에 지정된 사용자를 위한 로그인 쉘이 됩니다. 이는 해당 사용자 환경이 로드되고
작업 디렉토리가 그 사용자의 홈 디렉토리로 변경됨을 의미합니다.(환경변수까지 적용됨)

```shell

[me@linuxbox ~]$ su -
 Password:
[root@linuxbox ~]# exit
[me@linuxbox ~]$ 

```
> su -c 'command'

위 명령을 사용하면, 새로운 명령으로 시작하지 않고 단일 명령어 수행이 가능합니다.(sudo와 비슷)

#### sudo - 다른 사용자로 명령어 실행

관리자는 매우 통제된 방법하에서 일반 사용자가 다른 사용자(대게 슈퍼유저)로 명령을 실행할 수 있게끔 sudo를 설정할 수 있고
sudo는 슈퍼유저의 비밀번호를 요구하지 않습니다.

```shell

[me@linuxbox ~]$ sudo backup-script
 Password:
 System Backup Starting...
[me@linuxbox ~]$ 

```

#### chown - 파일 소유자와 그룹 변경

**chown 명령어**는 파일 또는 디렉토리의 소유자와 그룹 소유자를 변경하는 데 사용됩니다.
이 명령어를 사용하려면 수퍼유저 권한이 필요합니다.

> chown [owner] [:[group]] file ...

```shell

[janet@linuxbox ~]$ sudo cp my file.txt ~tony
 Password:
[janet@linuxbox ~]$ sudo ls -l ~Tony/myfile.txt
 -rw-r--r--  1 root  root  8031 2012-03-20 14:30 /home/tony/myfile.txt
[janet@linuxbox ~]$ sudo chown tony: ~tony/myfile.txt
[janet@linuxbox ~]$ sudo ls -l ~tony/myfile.txt
 -rw-r--r--  1 tony  tony  8031 2012-03-20 14:30 /home/tony/myfile.txt

```

#### chgrp - 그룹 소유권 변경

chown과 동일한 방식으로 동작합니다.

### 사용자 비밀번호 변경

비밀번호를 설정하거나 변경하기 위해 **passwd 명령어**를 사용합니다.

> passwd [user]

```shell

[me@linuxbox ~]$ passwd
 (Current) UNIX password:
 New UNIX password:

```
passwd 명령어는 "강력한" 비밀번호의 사용을 강요할 것입니다. 이는 비밀번호가 너무 짧거나 이전
비밀번호와 유사하거나, 사전 단어 또는 쉽게 유추할 수 있는 것이라면 설정을 거부할 것입니다.
슈퍼유저 특권을 가지고 있다면 passwd 명령의 첫 번째 인지에 사용자 이름을 지정해서 그 사용자의
비밀번호를 설정 할 수 있습니다.


# 프로세스






























