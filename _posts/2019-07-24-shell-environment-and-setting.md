---
layout: post
title:  "Shell Environment&Setting"
date:   2019-07-24 16:51:00 +0900
categories: [Language]
---
* TOC
{:toc}

# 환경

쉘은 쉘 세션이 진행되는 동안 모든 정보를 관리하는 **환경**을 유지합니다.
쉘 환경에 저장된 데이터는 설정 프로그램에 의해 사용됩니다. 대부분의 프로그램은 **환경설정 파일**을 사용하지만,
일부 프로그램은 동작하기 위해 환경에 설정된 값을 찾아보기도 합니다. 이러한 사실을 바탕으로 쉘 환경을 사용자에 맞게 설정할
수 있습니다.

### 환경에는 어떤 것들이 저장될까?

비록 bash에서는 구분하기 힘들지만 쉘은 환경에 두 가지 기본적인 형식을 저정합니다. 하나는 **환경 변수**고, 다른 하나는 **쉘 변수**입니다.
쉘 변수는 bash에 의해 저장된 작은 데이터고, 환경 변수는 기본적으로 그 밖의 모든 것입니다. 쉘은 변수뿐만 아니라, **별칭** 그리고 **쉘 함수**와 같은 프로그램 데이터도 저장합니다.

#### 환경 검증하기

환경에 저장된 것이 무엇인지 보려면 bash에 내장된 set 명령어나 printenv 프로그램을 사용하면 됩니다. **set 명령어**는 쉘 변수와 환경 변수 모두 보여주며, **printenv 명령어**는 오직 환경 변수만을 출력합니다.
환경 변수 내용이 길기 때문에 less 명령어를 사용하는 것을 추천합니다.

### 환경은 어떻게 설정할까?

시스템에 로그인하면 bash 프로그램이 시작되면서 **시작 파일**이라고 하는 일련의 환경 설정 스크립트를 읽습니다. 이 시작 파일은 모든 사용자에게 공유되는 기본적인 환경설정 값을 규정합니다.
이어서 개인 사용자의 환경을 정의하는 홈 디렉토리 내의 시작 파일이 구성됩니다. 정확한 순서는 실행된 쉘 세션에 따라 달라지게 됩니다.

#### 로그인 여부에 따른 쉘 환경

로그인 쉘 세션과 비 로그인 쉘 세션, 두 종류의 쉘 세션이 있습니다. **로그인 쉘 세션**에서는 사용자 이름과
비밀번호를 입력하도록 되어 있는데 예를 들면 가상 콘솔 세션이 시작할 때입니다. **비로그인 쉘 세션**은 일반적으로
GUI 환경에서 터미널 세션을 실행할 때 나타납니다.

로그인 쉘 세션용 시작 파일

|파일|내용|
|/etc/profile|모든 사용자에게 적용되는 일반 환경설정.|
|~/.bash_profile|개인 사용자 시작 파일. 일반 환경설정을 확장하거나 무시할 수 있습니다.|
|~/.bash_login|~/.bash_profile 파일이 없으면 bash는 이 스크립트를 읽게 됩니다.|
|~/.profile|~/.bash_profile이나 ~/.bash_login 모두 없으면 bash는 이 파일을 읽습니다.|

비로그인 쉘 세션용 시작 파일

|파일|내용|
|/etc/bash.bashrc|모든 사용자에게 적용되는 일반 환경설정.|
|~/.bash_rc|개인 사용자 시작 파일. 일반 환경설정을 확장하거나 무시할 수 있습니다.|

비로그인 쉘은 이 시작 파일을 읽는 것뿐만 아니라 주로 로그인 쉘 같은 상위 프로세스로부터 환경값을 물려 받습니다.
~/.bashrc 파일은 일반 사용자 관점에서 아마도 가장 중요한 파일일 것입니다. 왜나햐면 항상 참조되는 파일이기 때문입니다.
비로그인 쉘은 기본적으로 이 파일을 읽고, 로그인 쉘용의 시작파일 대부분은 ~/.bashrc 파일을 기본적으로 참조하도록 만들어지기 때문입니다.

#### 시작 파일에는 어떤 것이 있을까?

전형적인 .bash_profile 파일에는 다음과 같은 코드가 있습니다.

```shell
if [ -f ~/.bashrc ]; then
	. ~/.bashrc
fi
```

> If the file "~/.bashrc" exists, then read the "~/.bashrc" file.

위 코드로 어떻게 로그인 쉘이 .bashrc 파일 내용을 가져오는 볼 수 있습니다. 시작 파일에 있는 나머지
내용은 PATH 변수와 함께 수행됩니다. 커맨드라인에 명령어를 입력하면 쉘이 찾아내는 방법은 다음과 같다.
예를 들어, ls 명령어를 입력했을 때, 쉘은 /bin/ls를 찾기 위해서 쉘이 컴퓨터 전체를 검색하는 것이 아니라
PATH 변수에 있는 디렉토리를 대상으로만 검색을 하게 됩니다. PATH 변수는 주로 /etc/profile 시작 파일에서
다음 코드로 설정이 됩니다.
> PATH=$PATH:$HOME/bin

Path는 $HOME/bin 디렉토리를 목록 끝에 추가하도록 설정되어있다. 즉 사용자만의 프로그램을 저장하기 위해서 홈
디렉토리 내에 디렉토리를 생성하고 싶다면, 쉘은 그것을 수용할 준비가 되어있습니다. 우리가 할 일은 그것을 bin이라고
부르는 것입니다. 마지막으로 할 일입니다.
> export PATH

export 명령어는 쉘과 이 쉘의 자식 프로세스들에 PATH 내용을 적용하라고 알려줍니다.

### 환경 편집

이제 시작 파일이 어디에 있는지 또 어떤 내용이 들어있는지 알기 때문에, 우리만의 환경을 설정할 수 있습니다.

#### 어떤 파일을 수정해야 할까?

일반적인 규칙에 따라, 사용자의 PATH에 디렉토리를 추가하거나 부가적인 환경 변수를 정의하기 위해서는 .bash_profile 파일(or .profile) 내용을
수정해야 합니다. 그 밖의 다른것들은 .bashrc 파일에서 변경합니다. 자신이 시스템 관리자가 아니고 시스템에 있는 모든 사용자의 기본값을 수정할 필요가
없다면 홈 디렉토리에 있는 파일만을 편집하도록 합니다.

#### 텍스트 편집기

시작 파일 뿐만 아니라 시스템에 있는 다른 환경설정 파일을 편집하기 위해서는 **텍스트 편집기**라고 하는 프로그램을 사용합니다. 텍스트 편집기는 코드를
작성하는 소프트웨어 개발자들과 시스템을 제어하기 위해서 설정 파일을 관리해야 하는 시스템 관리자들이 사용하는 중심적인 도구입니다.
모든 텍스트 편집기는 커맨드라인에서 편집하려는 파일명 앞에 편집기 이름을 입력하면 해당 파일을 불러올 수 있습니다.
.bashrc 파일을 수정한뒤 저장하고 텍스트 편집기를 종료합니다.

#### 변경사항 적용하기

.bashrc 파일에 편집한 내용들은 터미널 세션을 종료하고 다시 새로 실행할 때까지 적용되지 않습니다. 왜냐하면, .bashrc 파일은 최초 세션이 시작될 때
참조되는 파일이기 때문입니다. 하지만 bash에 강제로 이 파일을 참조하도록 명령할수 있습니다.

```shell
[me@linuxbox ~]$ source .bashrc
```
이 명령을 한 후에, 변경 사항이 적용됐는지 반드시 확인해봐야 합니다.

# VI 맛보기

### vi를 왜 배워야 할까?

* vi는 어디에서나 사용할 수 있습니다.(원격 서버나 환경설정이 망가진 로컬 시스템)

* vi는 가볍고 빠릅니다. 시스템 메뉴에서 텍스트 편집기를 불러와서 프로그램을 실행될 때까지 기다리는 것보다는
vi 편집기를 불러오는 것이 훨씬 수월합니다. 그리고, 마우스를 사용하지 않아도 됩니다.

### vi 시작과 종료

vi를 시작하려면 다음과 같이 간단하게 입력하면 됩니다.
```shell
[me@linuxbox ~]$ vi
```

vi편집기를 종료하려면 다음 명령어를 입력합니다.

> :q

그럼 쉘 프롬프트가 다시 나타납니다. 어떤 이유에서든 vi가 종료되지 않으면(보통 파일을 저장 하지 않았을 경우)
느낌표를 추가해서 강제 종료할 수 있습니다.

> :q!

### 편집모드

다시 vi 편집기를 실행합니다. 이번에는 존재하지 않는 파일 이름을 입력합니다. 이것이 vi로 새 파일을 만드는 방법입니다.

```shell
[me@linuxbox ~]$ rm -f foo.txt
[me@linuxbox ~]$ vi foo.txt
```
이 명령이 잘 실행되었다면 다음과 같은 화면이 나타납니다.

```vim
~
~
~
~
~
"foo.txt" [NEW FILE]
```

앞에 나오는 ~ 기호들은 해당 줄에 아무런 텍스트가 없다는 것을 나타냅니다. 즉 파일이 비어있다는 뜻입니다.
아직은 아무것도 입력하면 안됩니다. vi가 실행되면 **명령어 모드**로 시작됩니다. 이 모드에서는 대분분의 모든
키가 명령어를 의미하므로 타이핑하면 vi가 엉망이 될 수 있습니다.

#### 텍스트 입력 모드로 들어가기

파일에 텍스트를 입력하기 위해서는 반드시 **텍스트 입력 모드**로 들어가야 합니다. 입력 모드로 들어가기
위해서는 I 키를 입력하면 됩니다. 그 다음엔 vim이 확장 모드에서 실행되고 있다면 화면 하단에 다음과 같이 보여야 합니다.
> -\- INSERT -\-

이제 텍스트를 입력합니다.
> the quick brown fox jumped over the lazy dog.

텍스트 입력모드를 종료하고 명령어 모드로 돌아가려면 ESC 키를 입력하면 됩니다.

#### 저장하기

파일에 변경된 사항을 저장하기 위해서는 반드시 **ex 명령어**를 명령어 모드에서 입력해야 합니다.
: 키의 입력으로 간단하게 할 수 있습니다. 그런 다음엔 콜론 기호가 화면 아래 나타나야 합니다.
> :

변경된 파일을 저장하려면, 콜론 다음에 w 문자를 입력하고 엔터키를 누릅니다.
> :w

파일은 하드 드라이브에 저장되고 다음과 같은 확인 메시지가 화면 아래쪽에 나타납니다.
> "foo.txt" [NEW] 1L, 46C written

### 커서 이동

커서 이동 키

|키|커서 이동 방향|
|L 또는 오른쪽 방향키|오른쪽 한 문자|
|H 또는 왼쪽 방향키|왼쪽 한 문자|
|J 또는 아래쪽 방향키|한 줄 아래로|
|K 또는 위쪽 방향키|한 줄 위로|
|0(zero)|현재 줄 처음으로|
|^|현재 줄 첫 번째 공백이 아닌 글자로|
|$|현재 줄 마지막으로|
|w|다음 단어나 구두점 기호 처음으로|
|W|다음 단어 처음으로. 구두점 기호 무시|
|b|이전 단어나 구두점 기호 처음으로|
|B|이전 단어 처음으로. 구두점 기호 무시|
|CTRL-F 또는 PAGE DOWN|한 페이지 아래로|
|CTRL-B 또는 PAGE UP|한 페이지 위로|
|number-SHIFT-G|줄 번호로 이동|
|SHIFT-G|파일의 마지막 줄로|

왜 H, J, K, L과 같은 문자가 커서 이동에 사용되는 이유는 vi가 처음 만들어졌을 때, 모든 비디오 터미널이 화살표 키를 가지고 있지 않았고 숙련된 키보드 사용자들은 키보드에서
다른 곳으로 손가락을 들어올리지 않고 커서를 이동하기 위해서 일반 키보드 키들을 사용했기 때문입니다. 또한 vi에 있는 많은 명령어 앞에 숫자를 붙일 수 있습니다. 명령어 앞에 숫자를
붙임으로써 명령어가 실행되어야 할 횟수를 지정할 수 있습니다. 예를 들어, 5j는 커서를 5줄 아래로 이동시켜줍니다.

### 기본 편집

#### 텍스트 덧붙이기

vi에는 몇 가지의 텍스트 입력 모드가 있습니다. 그 중에서도 이미 텍스트를 입력하기 위해 i 명령을 사용했습니다.
vi는 텍스트를 덧붙이기 위한 명령어를 제공합니다. 알아보기 쉽게 a라는 명령어를 사용합니다. 문장에 끝으로 커서를
이동하고($) a를 입력하면 커서는 그 줄 끝을 지나 추가되고 텍스트 입력 모드로 진입합니다.

#### 빈줄 추가

텍스트를 입력할 수 있는 다른 방법으로는 줄을 "띄우는" 것입니다.

빈 줄 추가 키

|명령어|실행|
|o|현재 줄 아래에 빈 줄 추가|
|O|현 줄 위에 빈 줄 추가|

#### 텍스트 삭제

텍스트 삭제 명령어

|명령어|삭제 내용|
|x|현재 문자|
|3x|현재 문자를 포함한 다음 2개 문자|
|dd|현재줄|
|5dd|현재 줄을 포함한 다음 4줄|
|dW|현재 커서 위치부터 다음 단어 앞까지|
|d$|현재 커서 위치부터 현재 줄 끝까지|
|d0|현재 커서 위치부터 현재 줄 맨 앞까지|
|d^|현재 커서 위치부터 그 줄의 공백이 아닌 첫 번째 글자까지|
|dG|현재 줄부터 그 파일 끝까지|
|d20G|현재 줄부터 파일의 20번째 줄까지|

#### 텍스트 자르기, 복사하기 그리고 붙이기

복사 명령어

|명령어|복사 내용|
|yy|현재 줄|
|5yy|현재 줄을 포함한 다음 4줄|
|yW|현재 커서 위치부터 다음 단어 앞까지|
|y$|현재 커서 위치부터 현재 줄 끝까지|
|y0|현재 커서 위치부터 현재 줄 맨 앞까지|
|y^|현재 커서 위치부터 그 줄의 공백이 아닌 첫 번째 글자까지|
|yG|현재 줄부터 그 파일 끝까지|
|y20G|현재 줄부터 파일의 20 번째 줄까지|

#### 줄 합치기

현재 줄에 J 명령어를 사용하면 다음줄과 공백 한 칸을 두고 합쳐집니다.

### 검색 및 치환

#### 줄에서 텍스트 검색

f 명령어는 줄을 검색해서 찾으려는 문자 위치로 커서를 이동시킵니다. 예를 들어, fa 명령어는 현재 줄에
있는 a 문자를 찾아 이동시킵니다. 검색을 수행하고 나서 세미콜론을 입력하면 반복 검색이 가능합니다.

#### 파일에서 텍스트 검색

단어나 문장에서 검색된 위치로 커서를 이동하기 위해서 / 명령어가 사용됩니다. /명령어를 입력하면, 슬래시가
화면 아래쪽에 나타납니다. 그 다음, 검색하려는 단어나 문장을 입력하고 엔터키를 누릅니다. n 명령어를 사용하면
다음 검색어로 커서가 넘어갑니다.(N은 이전 검색어로 커서가 이동함)

#### 전체 검색 및 치환

vi는 ex 명령어(:)를 사용하여 해당 줄이나 파일 전체에서 검색할 내용을 찾아서 바꾸기 작업을 수행합니다. 파일 전체에서 Line을 line으로
바꾸기 위해 다음과 같은 명령어를 입력해야 합니다.

> :%s/Line/line/g

각각의 치환이 실행되기 전에, vi 는 확인 메시지를 다음과 같이 보여줍니다.

> replace with Line(y/n/a/q/l/^E/^Y)?

치환 명령 확인 메시지 키

|키|실행|
|y|치환 실행|
|n|이번 치환 건너뛰기|
|a|전체 치환 실행|
|q or ESC|치환 중단|
|l|이번 치환 후 종료|
|CTRL-E, CTRL-Y|스크롤 위 아래로 이동하기. 치환 내용을 확인할 때 유용함.|

### 다중 파일 편집

여러 파일을 수정해야할 경우나 한 파일에서 다른 파일로 내용을 복사해야 할 경우가 있을 수 있습니다. 커맨드라인에
다음과 같이 여러 파일을 지정하여 연 다음 vi로 편집할 수 있습니다.

> vi file1 file2 file3...

이전 vi 세션을 종료하고 새 파일을 편집합니다. :wq를 입력해서 vi를 종료하고, 수정된 사항을 저장합니다.
그 다음, 우리가 작업한 후 홈 디렉토리에 다른 파일을 만듭니다. ls 출력 결과를 가져와서 파일을 만듭니다.

```shell
[me@linuxbox ~]$ ls -l /usr/bin > ls-output.txt
```
vi로 이전 파일과 새 파일을 편집합니다.

```shell
[me@linuxbox ~]$ vi foo.txt ls-output.txt
```
vi가 실행되면 첫 번째 파일이 화면에 나타날 것입니다.

#### 파일 간 전환

현재 파일을 다음 파일로 전환하려면, ex 명령어를 사용합니다.

> :n

이전 파일로 되돌아가려면 다음과 같이 입력합니다.

> :N

vi는 다른 파일로 전환할 때, 현재 파일이 저장되지 않았으면 파일을 전환할 수 없도록 하고 있습니다.
강제로 파일을 전환하고 변경 사항을 저장하지 않으려면 명령어에 느낌표를 붙이면 됩니다. vim은 여러 파일을
관리하기 쉽도록 ex 명령어 일부를 지원합니다. :buffers 명령어로 수정 중인 파일 목록을 볼 수 있습니다.
다른 버퍼(파일)로 전환하려면 :buffer 명령어 다음에 수정하려는 버퍼 번호를 입력하면 됩니다. 예를 들어,
foo.txt 파일이 있는 버퍼 1에서 ls-output.txt가 있는 버퍼 2로 전환하고 싶으면 다음과 같이 입력하면
됩니다.

>:buffer 2

그럼 화면에는 두 번쨰 파일이 표시될 것입니다.

#### 다른 파일 열어서 편집

현재 편집 세션에 파일을 추가할 수도 있습니다. ex 명령어인 :e(edit의 준말) 다음에 파일명을 입력하면
다른 파일을 열 수 있습니다. 일단 현재 편집 세션을 종료하고 커맨드라인으로 돌아갑니다.
그리고 하나의 파일로 vi 편집기를 다시 시작합니다.

```shell
[me@linuxbox ~]$ vi foo.txt
```

두 번째 파일을 열기 위해서 다음과 같이 입력합니다.

> :e ls-output.txt

그럼 화면에 이 파일이 나타납니다. 첫 번째 파일이 여전히 열려있음을 확인할 수 있습니다.
(:n, :N 불가능, :buffer 이용)

#### 파일 내용을 다른 파일로 복사

:buffer 명령어와 yy, p 명령어를 이용합니다.

#### 파일 전체를 다른 파일에 삽입

현재 편집중인 파일에 다른 파일 내용 전체를 삽입하는 것도 가능합니다. 실행 과정을 보기 위해 현재
vi 세션을 종료하고 하나의 파일로 다시 vi 편집기를 실행합니다.

```shell
[me@linuxbox ~]$ vi ls-output.txt
```
커서를 붙여넣을 위치로 이동하여 다음과 같은 ex 명령어를 입력합니다.

> :r foo.txt

:r 명령어(read의 준말)는 지정한 파일을 커서 위치 바로 앞에 삽입합니다.

#### 저장하기

vi의 다른 기능들처럼 편집한 파일을 저장하는 데에도 여러 방법이 있습니다. 이미 ex 명령어인 :w를
알고 있지만 도움이 될 만한 다른 명령어들도 있습니다.

명령어 모드에서 ZZ를 입력하여 현재 파일을 저장하고 vi를 종료할 수 있습니다. 유사하게, ex 명령어인 :wq
는 :w와 :q 명령어가 결합한 형태로 파일을 저장하고 종료하는 작업을 수행합니다.
:w 명령어는 파일명을 지정할 수 있습니다. 이는 다른 이름으로 저장하기와 비슷한 것입니다.

> :w fool.txt

# 프롬프트 커스터마이징

### 프롬프트 해부하기

기본 프롬프트 모양은 다음과 같습니다.

```shell
[me@linuxbox ~]$ 
```
어떻게 이런 정보를 표시했을까? 프롬프트는 ps1이라고 하는 환경 변수에 의해 정의됩니다. echo 명령어로 psl 내용을 살펴봅니다.

```shell
[me@linuxbox ~]$ echo $PS1
[\u@\h \W]\$
```
쉘 프롬프트에서 사용되는 이스케이프 문자

|시퀀스|표시 값|
|\a|ASCII 벨소리. 이 문자가 사용되면 컴퓨터에서 알림 소리가 납니다.|
|\d|현재 날짜|
|\h|로컬 장치의 호스트명(도메인명 제외)|
|\H|호스트명|
|\j|현재 쉘 세션에서 실행중인 작업 개수|
|\l|현재 터미널 장치 이름|
|\n|개행 문자|
|\r|캐리지 리턴|
|\s|쉘 프로그램 이름|
|\t|24시간 기준, 시간:분:초 포맷의 현재 시간|
|\T|12시간 기준, 현재시간|
|\@|12시간 기준, AM/PM 포맷의 현재 시간|
|\A|현재 사용자의 사용자 이름|
|\u|현재 사용자의 사용자 이름|
|\v|쉘 버전정보|
|\V|쉘 버전 및 릴리즈 정보|
|\w|현재 작업 디렉토리의 전체 경로명|
|\W|현재 작업 디렉토리명|
|\\!|현재 명령어의 히스토리 번호|
|\\#|현재 쉘 세션에 입력된 명령어 개수|
|\\$|슈퍼유저 권한일 경우 $ 값을 표시합니다. 현재는 # 값을 표시|
|\\[|이 기호는 하나 이상의 출력되지 않는 일련의 문자들의 시작을 나타냅니다. 커서를 이동한다거나 텍스트 색상을 변경하는 것과 같은 터미널 에뮬레이터를 조작하는 비출력 제어 문자들을 끼워 넣을 때 사용합니다.|
|\\]|이 기호는 비출력 제어 문자의 끝을 나타냅니다.|

### 다른 형태의 프롬프트 사용해보기

이러한 특수 문자를 활용해서 프롬프트에 변화를 줄 수 있습니다. 기존 문자열은 백업해두고 추후에 다시 되돌릴 수 있도록 해둡니다.
그러기 위해서 기존 문자열을 우리가 만들려고 하는 또 다른 쉘 변수로 복사해둡니다.
```shell
[me@linuxbox ~]$ ps1_old="$PS1"
[me@linuxbox ~]$ echo $ps1_old
[\u@\h \W]\$
[me@linuxbox ~]$ PS1="$ps1_old"
```
```shell
[me@linuxbox ~]$ PS1=
```
아직은 아무것도 없습니다. 프롬프트 문자열에 아무것도 보이지 않는다. 프롬프트가 있긴 하지만 일부러
그렇게 만들었기 때문에 아무것도 표시되지 않고 있습니다. 이렇게 당황스러운 모양이 나타나게 되면, 축소형
프롬프트로 바꿔볼 수 있습니다.

```shell
PS1="\$ "
```
최소한 우리가 지금 무엇을 하고 있는지 알 수 있습니다. 프롬프트에 알람 소리도 추가합니다.

```shell
$ PS1="\a\$ "
```
이젠, 프롬프트가 표시될 때마다 알림 소리가 들려야 합니다.
다음으로, 호스트명과 현재 시간 정보를 보여주는 프롬프트를 만들어봅니다.

```shell
$ PS1="\A \h \$ "
17:33 linuxbox $ 
```

특정한 작업을 수행한 시간을 알고 싶을 때, 이 기능을 매우 쓸만합니다. 마지막으로, 프롬프트 모양을 원래 모양과 비슷한 형태로
다시 만들어봅니다.

```shell
17:37 linuxbox $ PS1="<\u@\h \W>\$ "
<me@linuxbox ~>$ 
```

### 색상 추가

대부분의 터미널 에뮬레이터 프로그램은 문자 속성(텍스트 색상, 굵기, 깜박임)과 커서 위치 등을
제어하기 위해 특정한 비출력 문자 시퀀스를 사용할 수 있습니다.
문자 색상은 표시될 문자열에 내장된 **ANSI 이스케이프 코드**를 터미널 에뮬레이터에 전송함으로써 제어됩니다.
제어 코드는 화면에 "출력"되는 것이 아니라 하나의 명령어로 터미널에 해석됩니다. \\[ 및 \\] 시퀀스는 비출력
문자를 나타나게 할 때 사용됩니다. ANSI 이스케이프 코드는 8진법의 033으로 시작하고, 그 뒤에 오는 것은 부가적인
문자 속성이나 명령입니다. 색상은 크게 두 그룹으로 분류됩니다. 글자 볼드 속성(0,1)의 적용에 따라 나뉘는데, 이
값은 각각 어둡고 밝은 색상을 표현해줍니다.

텍스트 색상 설정을 위한 이스케이프 시퀀스

|시퀀스|텍스트 색상|
|\033[0;30m|검정|
|\033[0;31m|빨강|
|\033[0;32m|초록|
|\033[0;33m|갈색|
|\033[0;34m|파랑|
|\033[0;35m|보라|
|\033[0;36m|청록|
|\033[0;37m|연회색|
|\033[1;30m|진회색|
|\033[1;31m|밝은 빨강|
|\033[1;32m|연초록|
|\033[1;33m|노랑|
|\033[1;34m|연파랑|
|\033[1;35m|연보라|
|\033[1;36m|연청록|
|\033[1;37m|흰색|

이제 프롬프트를 빨간색으로 바꿔봅니다. 맨 첫 부분에 이스케이프 코드를 추가합니다.

```shell
<me@linuxbox ~>$ PS1="\[\033[0;31m\]<\u@\h \W>\$ "
```
색상이 바뀌었지만 프롬프트 다음에 입력하는 글자들도 빨갛게 나오므로 다른 이스케이프
코드를 프롬프트 끝에 넣어서 이전 색상으로 표시되도록 합니다.

```shell
<me@linuxbox ~>$ PS1="\[\033[0;31m\]<\u@\h \W>\$\[\033[0m\] "
```
바탕색 설정을 위한 이스케이프 시퀀스

|시퀀스|바탕색|
|\033[0;40m|검정|
|\033[0;41m|빨강|
|\033[0;42m|초록|
|\033[0;43m|갈색|
|\033[0;44m|파랑|
|\033[0;45m|보라|
|\033[0;46m|청록|
|\033[0;47m|연회색|

첫 번쨰 이스케이프 코드의 변경으로 프롬프트의 바탕을 빨간색으로 바꿔봅니다.

```shell
<me@linuxbox ~>$ PS1="\[\033[0;41m\]<\u@\h \W>\$\[\033[0m\] "
```

### 커서 이동

이스케이프 코드는 커서의 위치를 결정할 때도 사용됩니다. 화면상의 다른 위치에 있는 시간이나 다른 종류의
정보를 표현하고자 할 때 주로 쓰입니다. 예를 들면, 프롬프트가 표시될 때마다 화면 상단에 그 정보를 보여주는
것입니다.

커서 이동 이스케이프 시퀀스

|이스케이프 코드|실행|
|\033[l;cH|l줄 c열로 커서 이동|
|\033[nA|n줄만큼 위로 이동|
|\033[nB|n줄만큼 아래로 이동|
|\033[nC|n개 문자만큼 앞으로|
|\033[nD|n개 문자만큼 뒤로|
|\033[2J|화면을 지우고 좌측 상단으로(위치: 줄 0, 열 0)|
|\033[K|현재 커서 위치에서부터 현재 라인 끝까지 삭제|
|\033[s|현재 커서 위치 저장|
|\033[u|저장된 커서 위치 불러오기|

이 코드들을 활용하여, 화면 상단에 빨간 줄의 시간 정보(노란색 텍스트)가 있는 프롬프트를 만들 수 있습니다.

```shell
PS1="\[\033[s\033[0;0H\033[0;41m\033[k\033[1;33m\t\033[0m\033[u\]<\u@\h \W>\$ "
```

### 프롬프트 저장

위와 같이 긴 코드를 매번 입력하고 싶지는 않을 겁니다. 따라서 이러한 프롬프트 설정 코드를 따로 저장해두어야 합니다.
.bashrc 파일에 이 정보를 저장하게 되면 이 프롬프트를 계속 사용할 수 있습니다. 다음 두 줄을 파일에 삽입합니다.

```shell
PS1="\[\033[s\033[0;0H\033[0;41m\033[k\033[1;33m\t\033[0m\033[u\]<\u@\h \W>\$ "

export PS1
```



